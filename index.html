<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR 포인트 헌터 (Prototype)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet.js (Map) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- three.js (3D/AR) - ES Module -->
    <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
      }
    }
    </script>

    <!-- Chosen Palette: Toss-Inspired Blue & Map UI -->
    <!-- Application Structure Plan: 이 앱은 '지도 탐색'과 'AR 경험'이라는 두 가지 핵심 상태를 갖습니다. 1) '지도 화면(screen-map)'이 기본이며, Leaflet.js를 사용해 사용자와 가맹점 위치를 실시간 표시합니다. 2) Geolocation API로 거리를 계산하여 20m 이내일 때 'AR 시작' 버튼을 활성화합니다. 3) 'AR 시작' 버튼 클릭 시, 'AR 오버레이(screen-ar-overlay)'가 활성화되고 WebXR 세션이 시작됩니다. 4) three.js가 AR 공간에 3D 객체를 렌더링하고, 터치(Raycaster)로 객체 획득 상호작용을 처리합니다. 이 구조는 GPS 기반 탐색과 몰입형 AR 경험을 자연스럽게 연결합니다. -->
    <!-- Visualization & Content Choices: 지도: 정보(위치) -> 목표(탐색) -> Leaflet.js 맵 -> 사용자가 실제 세계에서 가맹점과의 거리/방향을 직관적으로 인지 -> Leaflet.js + Geolocation API. | AR 오브젝트: 정보(리워드) -> 목표(획득) -> 3D TorusKnot(도넛) -> 사용자가 카메라 뷰에서 리워드를 시각적으로 발견하고 터치로 획득 -> three.js + WebXR API. 이 방식들은 실제 API를 사용하여 기획안의 핵심 기능을 프로토타입으로 구현합니다. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <style>
        body, html {
            overscroll-behavior: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #app-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #f0f0f0;
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
        }
        .screen.active {
            display: flex;
        }
        #map {
            width: 100%;
            flex-grow: 1; /* 지도가 남은 공간을 모두 차지 */
            z-index: 10;
        }
        #info-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 20;
        }
        /* AR 캔버스는 three.js가 자동으로 전체 화면으로 만듭니다 */
        #screen-ar-overlay {
            z-index: 30;
            pointer-events: none; /* AR 씬 터치를 방해하지 않도록 */
        }
        #screen-ar-overlay > * {
            pointer-events: auto; /* 버튼 등 UI 요소는 터치 가능하도록 */
        }
        #modal-reward-content.active {
            transform: scale(1);
            opacity: 1;
        }
        .leaflet-control-attribution {
            display: none; /* 지도 저작권 표시 숨김 (테스트용) */
        }
    </style>
</head>
<body>
    <div id="app-container">

        <!-- Screen 1: Loading -->
        <div id="screen-loading" class="screen active items-center justify-center text-center p-8 bg-white">
            <h1 class="text-2xl font-bold text-gray-800 mb-4">AR 포인트 헌터</h1>
            <p class="text-gray-600">현재 위치를 확인 중입니다...</p>
            <p class="text-gray-500 text-sm mt-4">브라우저의 위치 정보 접근을 허용해주세요.</p>
        </div>

        <!-- Screen 2: Map View -->
        <div id="screen-map" class="screen">
            <div id="map"></div>
            <div id="info-panel" class="bg-white p-4 shadow-t-lg rounded-t-2xl">
                <div class="text-center">
                    <h2 class="text-xl font-bold">[A Gachon Cafe]</h2>
                    <p id="distance-info" class="text-lg text-gray-600 mt-1">계산 중...</p>
                </div>
                <button id="btn-start-ar" class="w-full bg-blue-600 text-white font-bold text-lg py-4 px-6 rounded-xl mt-4 shadow-lg transition-all transform disabled:bg-gray-400 disabled:opacity-50" disabled>
                    AR로 포인트 잡기
                </button>
            </div>
        </div>

        <!-- Screen 3: AR UI Overlay -->
        <div id="screen-ar-overlay" class="screen justify-between p-4">
            <button id="btn-close-ar" class="bg-black bg-opacity-40 text-white w-12 h-12 rounded-full text-2xl font-bold leading-10 text-center">
                X
            </button>
            
            <!-- AR 획득 모달 -->
            <div id="modal-reward" class="absolute inset-0 hidden items-center justify-center bg-black bg-opacity-60 z-50">
                <div id="modal-reward-content" class="bg-white rounded-2xl shadow-2xl w-full max-w-sm text-center p-8 m-4 transform scale-0 opacity-0 transition-all duration-300">
                    <div class="text-6xl mb-4">🎉</div>
                    <h2 class="text-3xl font-bold text-gray-900 mb-2">획득!</h2>
                    <p class="text-lg text-gray-700 mb-6">
                        <span id="reward-name" class="font-bold text-blue-600">1,000 포인트</span>를 잡았습니다!
                    </p>
                    <button id="btn-claim-reward" class="w-full bg-blue-600 text-white font-bold py-4 px-6 rounded-lg">
                        확인
                    </button>
                </div>
            </div>
        </div>

        <!-- Screen 4: Unsupported -->
        <div id="screen-unsupported" class="screen items-center justify-center text-center p-8 bg-white">
            <h1 class="text-2xl font-bold text-red-600 mb-4">오류</h1>
            <p class="text-gray-700">이 기기 또는 브라우저에서는 WebXR(AR)을 지원하지 않습니다.</p>
            <p class="text-gray-500 text-sm mt-4">최신 버전의 Chrome 또는 Safari를 사용해주세요.</p>
        </div>

    </div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        const screens = {
            loading: document.getElementById('screen-loading'),
            map: document.getElementById('screen-map'),
            arOverlay: document.getElementById('screen-ar-overlay'),
            unsupported: document.getElementById('screen-unsupported')
        };
        
        const infoPanel = document.getElementById('distance-info');
        const arButton = document.getElementById('btn-start-ar');
        const closeArButton = document.getElementById('btn-close-ar');
        const modalReward = document.getElementById('modal-reward');
        const modalRewardContent = document.getElementById('modal-reward-content');
        const claimRewardButton = document.getElementById('btn-claim-reward');

        let map, userMarker, merchantMarker;
        let merchantLatLng = null; // [lat, lng]
        let userLatLng = null; // [lat, lng]
        const activationDistance = 20; // 20m 이내

        let camera, scene, renderer, controller;
        let arObject;
        let xrSession = null;

        function showScreen(screenId) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            if (screens[screenId]) screens[screenId].classList.add('active');
        }

        // --- Map Logic (Leaflet.js) ---

        function initMap(firstPos) {
            userLatLng = [firstPos.coords.latitude, firstPos.coords.longitude];
            
            // 테스트를 위해 사용자의 첫 위치에서 북쪽으로 50m 지점에 가맹점 생성
            merchantLatLng = calculateOffset(userLatLng[0], userLatLng[1], 50, 0); 

            map = L.map('map').setView(userLatLng, 18); // 18 zoom level

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
            }).addTo(map);

            userMarker = L.circle(userLatLng, {
                color: '#1B64F2',
                fillColor: '#1B64F2',
                fillOpacity: 0.3,
                radius: 5 // 5m 반경
            }).addTo(map);
            
            merchantMarker = L.marker(merchantLatLng).addTo(map)
                .bindPopup('<b>A Gachon Cafe</b><br>AR 포인트 획득 가능!')
                .openPopup();

            showScreen('map');
            updateDistance();
            
            // Geolocation API로 사용자의 위치를 실시간 추적합니다.
            navigator.geolocation.watchPosition(updateUserPosition, handleLocationError, { enableHighAccuracy: true });
        }

        function updateUserPosition(pos) {
            userLatLng = [pos.coords.latitude, pos.coords.longitude];
            userMarker.setLatLng(userLatLng);
            map.panTo(userLatLng); // 사용자를 따라 지도 이동
            updateDistance();
        }

        function updateDistance() {
            if (!userLatLng || !merchantLatLng) return;

            const dist = haversineDistance(userLatLng, merchantLatLng);
            infoPanel.textContent = `가맹점까지 약 ${dist.toFixed(0)}m 남았습니다.`;

            if (dist <= activationDistance) {
                arButton.disabled = false;
                arButton.textContent = 'AR로 포인트 잡기 (활성화!)';
            } else {
                arButton.disabled = true;
                arButton.textContent = 'AR로 포인트 잡기';
            }
        }

        function handleLocationError(error) {
            console.error("Geolocation Error:", error.message);
            infoPanel.textContent = "위치 정보를 가져올 수 없습니다.";
        }

        // --- AR Logic (Three.js + WebXR) ---

        async function initXR() {
            // 'xr' API가 브라우저에 존재하는지 확인합니다.
            if (!('xr' in navigator)) {
                showScreen('unsupported');
                return;
            }
            
            // 'immersive-ar' (AR) 세션을 지원하는지 확인합니다.
            const isSupported = await navigator.xr.isSessionSupported('immersive-ar');
            if (!isSupported) {
                showScreen('unsupported');
                return;
            }

            // WebGL 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            // AR 캔버스를 body에 추가 (실제 AR 세션이 시작되면 이 캔버스가 패스스루를 담당)
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.zIndex = '25';
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // AR 환경에 빛 추가
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);
            
            // 컨트롤러 (터치 감지용)
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect); // 'select'는 화면 터치에 해당
            scene.add(controller);

            // 버튼 이벤트 리스너 연결
            arButton.addEventListener('click', activateXR);
            closeArButton.addEventListener('click', endXR);
            claimRewardButton.addEventListener('click', hideModal);
        }

        async function activateXR() {
            try {
                // AR 세션을 요청합니다 (카메라 접근 권한 요청 발생)
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test'] // 평면 인식을 사용하면 좋지만, 없어도 됨
                });
                onSessionStarted(xrSession);
            } catch (e) {
                console.error("AR 세션 시작 실패:", e);
                showScreen('unsupported');
            }
        }
        
        function onSessionStarted(session) {
            showScreen('arOverlay'); // UI 오버레이 표시
            session.addEventListener('end', onSessionEnded);
            renderer.xr.setReferenceSpaceType('local');
            renderer.xr.setSession(session);
            renderer.setAnimationLoop(onXRFrame); // 렌더링 루프 시작
            spawnArObject(); // AR 객체 생성
        }

        function onSessionEnded() {
            xrSession = null;
            renderer.setAnimationLoop(null);
            showScreen('map'); // 지도 화면으로 복귀
            // AR 객체 정리
            if (arObject) {
                scene.remove(arObject);
                arObject = null;
            }
        }
        
        function endXR() {
            // 사용자가 X 버튼을 눌러 AR 세션 종료
            if (xrSession) {
                xrSession.end();
            }
        }

        function onXRFrame(time, frame) {
            // 매 프레임마다 AR 카메라 위치/방향 업데이트
            const referenceSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();
            
            if (!referenceSpace) return;
            
            const pose = frame.getViewerPose(referenceSpace);
            if (pose) {
                camera.matrix.fromArray(pose.transform.matrix);
                camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
                camera.updateMatrixWorld(true);
            }
            
            // AR 객체 애니메이션 (제자리에서 빙글빙글)
            if (arObject) {
                arObject.rotation.y += 0.01;
                arObject.rotation.x += 0.005;
            }

            // 씬 렌더링
            renderer.render(scene, camera);
        }

        function spawnArObject() {
            // 3D 포인트 객체 생성 (파란색 도넛)
            const geometry = new THREE.TorusKnotGeometry(0.2, 0.05, 100, 16);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x1B64F2, 
                shininess: 100 
            });
            arObject = new THREE.Mesh(geometry, material);
            
            // 카메라 앞 2m, 약간 아래에 배치
            arObject.position.set(0, -0.2, -2);
            arObject.userData.rewardName = '1,000 포인트'; // 객체에 리워드 정보 저장
            scene.add(arObject);
        }
        
        function onSelect(event) {
            // 화면 터치 시 실행
            if (!arObject) return; // 잡을 객체가 없으면 무시

            const raycaster = new THREE.Raycaster();
            const tempMatrix = new THREE.Matrix4();
            
            // 터치한 위치로 Raycaster 설정
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            // Raycaster가 AR 객체와 충돌하는지 확인
            const intersects = raycaster.intersectObject(arObject);

            if (intersects.length > 0) {
                // 충돌했다면 객체 획득
                captureObject(intersects[0].object);
            }
        }
        
        function captureObject(object) {
            // 모달에 리워드 이름 표시
            document.getElementById('reward-name').textContent = object.userData.rewardName;
            showModal();
            scene.remove(object); // 씬에서 객체 제거
            arObject = null; // 잡았으니 null 처리
        }

        function showModal() {
            modalReward.style.display = 'flex';
            setTimeout(() => {
                modalRewardContent.classList.add('active');
            }, 10);
        }
        
        function hideModal() {
            modalRewardContent.classList.remove('active');
            setTimeout(() => {
                modalReward.style.display = 'none';
                // 모든 객체를 잡았으면 (지금은 1개) AR 종료
                if (!arObject) {
                    endXR();
                }
            }, 300);
        }


        // --- Utility Functions ---

        // 두 GPS 좌표 간의 거리를 미터(m) 단위로 계산 (Haversine 공식)
        function haversineDistance([lat1, lon1], [lat2, lon2]) {
            const R = 6371e3; // metres
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // in metres
        }
        
        // 기준 좌표에서 특정 거리(m)와 방위각(degree)만큼 떨어진 새 좌표 계산
        function calculateOffset(lat, lon, distance, bearing) {
            const R = 6371e3; // metres
            const brng = bearing * Math.PI / 180; // Bearing is 0°(N), 90°(E), 180°(S), 270°(W)
            const d = distance;

            const lat1 = lat * Math.PI / 180;
            const lon1 = lon * Math.PI / 180;

            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d / R) +
                         Math.cos(lat1) * Math.sin(d / R) * Math.cos(brng));

            const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(d / R) * Math.cos(lat1),
                                 Math.cos(d / R) - Math.sin(lat1) * Math.sin(lat2));

            return [lat2 * 180 / Math.PI, lon2 * 180 / Math.PI];
        }

        // --- App Initialization ---

        document.addEventListener('DOMContentLoaded', () => {
            // (1) 먼저 사용자의 현재 위치를 요청합니다. (GPS 권한 요청 발생)
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    // (2) 위치를 성공적으로 가져오면 지도 초기화를 시작합니다.
                    initMap(pos);
                    // (3) 동시에 AR 기능(three.js)을 준비시킵니다.
                    initXR();
                },
                (err) => {
                    // 위치 정보 권한이 거부되거나 실패했을 때
                    console.error(err.message);
                    showScreen('loading');
                    screens.loading.innerHTML = '<p class="text-red-600 p-8">위치 정보 권한이 필요합니다. 페이지를 새로고침하고 권한을 허용해주세요.</p>';
                },
                // Geolocation 옵션: 정확도 높게, 타임아웃 10초
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        });

    </script>
</body>
</html>

